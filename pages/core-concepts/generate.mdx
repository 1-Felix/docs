import { Callout, Tabs, Tab } from "nextra/components"
import { TutorialSchema } from "../../components/TutorialSchema"

# Generate data

<Callout emoji="🐥">
  This is a preview feature. We would love your [feedback](https://app.snaplet.dev/chat)!
</Callout>

## The need for generated data

Generated data, or seed data, is a useful tool in software development, providing an initial set of data for your database.

Here's why it's beneficial:

- **Development:** Provides a consistent dataset for developers.
- **Testing:** Ensures predictability when verifying features.
- **Demonstration:** Showcases your software's abilities with example content.
- **Default Data:** Adds necessary built-ins, like country lists.
- **Onboarding:** Gives new users a filled-out starting point.
- **Performance:** Helps simulate heavy usage scenarios.
- **Guides:** Common reference in tutorials.

While generated data might be the unsung hero of early development, it can get a bit needy as software evolves. But don't sweat it! Our mission is to save you from the never-ending saga of maintaining those seed scripts. Who has time for that, right?

## Introducing the Snaplet Data Client

The key to effortless generated data is a tool that deeply understands your database's schema. By introspecting your database, we are able to create a fully-typed client dedicated to data generation.

Right now, the Snaplet Data Client is tied to our configuration file, but we intend to generate a standalone version that you will be able to use anywhere!

Let's see how it works.

## Generating data with `snaplet generate`

You can refer to the [Generate Quick Start Guide](/getting-started/quick-start/generate) to learn about the basics of the `snaplet generate` command.

### Inside Snaplet Data Client workflow

#### Deterministic data generation

The data generated by the Snaplet Data Client is fully deterministic, if you run the same plan twice, you will get the same data.
Our default data generation functions are based on [copycat](https://github.com/snaplet/copycat).

We generate **seed** values based on the paths of your plans:

```ts
snaplet.Post({
  User: {
    // seed = 0/Post/0/User/email
    email: ({ seed }) => copycat.email(seed),
  }
})
```

It means that those users will have the same ids, even if you specified a different email:

```ts
await snaplet.User({
  // seed = 0/User/id
  id: ({ seed }) => seed,
  email: 'alice@acme.com'
})

await snaplet.User({
  // seed = 0/User/id
  id: ({ seed }) => seed,
  email: 'bob@acme.com'
})
```

If you want to be ensured that the values are different, you can wrap your different plans into [operators](/core-concepts/generate#manipulating-stores) like `snaplet.$merge`:

```ts
await snaplet.$merge(
  snaplet.User({
    // seed = 0/User/id
    id: ({ seed }) => seed,
    email: 'alice@acme.com'
  }),
  snaplet.User({
    // seed = 1/User/id
    id: ({ seed }) => seed,
    email: 'bob@acme.com'
  })
)
```

The operators are aware of the plans they are wrapping, and will generate different seeds for each plan. But an operator as a whole will still be deterministic.

You can also use the `seed` option to specify a custom seed for a plan:

```ts
await snaplet.User({
  // seed = hello/0/User/id
  id: ({ seed }) => seed,
  email: 'alice@acme.com'
}, { seed: 'hello' })

await snaplet.User({
  // seed = world/0/User/id
  id: ({ seed }) => seed,
  email: 'bob@acme.com'
}, { seed: 'world' })
```

#### Plans, stores and SQL statements

The **plan** is what's returned by the methods of the Snaplet Data Client. It's a representation of the data you want to generate.

```ts
const userPlan = snaplet.User({ email: 'snappy@snaplet.dev' });
//    ^ the plan                ^ the plan's inputs
```

When a plan is executed, triggered by `await`ing the plan, it stores the generated data in an in-memory object called a **store**.
Each plan has its own store.
Then, the store is turned into **SQL statements** that are executed to persist the data in your database.

Given the plan from the [Generate Quick Start Guide](/getting-started/quick-start/generate):

```ts snaplet.config.ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
    async run(snaplet) {
      await snaplet.Post({
        title: 'Hello World!',
        User: {
          email: ({ seed }) =>
            copycat.email(seed, {
              domain: 'acme.org',
            }),
        },
        Comment: (x) => x(3),
      });
    },
  },
});
```

Here is what its store looks like internally:

```ts
const store = {
  User: [User, User, User, User],
  Post: [Post],
  Comment: [Comment, Comment, Comment],
}
```

This store is very useful when you want to [connect](/core-concepts/generate#connecting-to-existing-data) your models, reusing existing data instead of generating new one.


### Static or dynamic data, we got you covered

If you want to use static data, you can directly pass an object or an array to the models methods.
As always, all the required fields and relationships will be automatically created for you based on your database schema.

```ts
// a single User
snaplet.User({ email: 'forever.alone@acme.com' });

// an array of 2 Users
snaplet.User([
  { email: 'alice@acme.com' },
  { email: 'bob@acme.com' },
]);
```

If you want to use dynamic data, you can pass a callback function to the models methods. We inject a function `x` that you can use to generate as many models as you want.

```ts
// an array of 10 Users
snaplet.User((x) => x(10));

// an array of 10 Users with a custom email
snaplet.User((x) => x(10, (index) => ({
  email: `user${index}@snaplet.dev`,
})));
```

And if you need both static and dynamic data, you can mix them together!

```ts
// an array of 10 Users
snaplet.User((x) => [
  { email: 'first@acme.com' },
  ...x(8),
  { email: 'last@acme.com' },
])
```

### Connecting data

#### Using `connect` callback function

<CH.Scrollycoding className="generate-tutorial-configuration-file">

Let's start from our previous plan.

```ts snaplet.config.ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
    async run(snaplet) {
      await snaplet.Post({
        title: 'Hello World!',
        User: {
          email: ({ seed }) =>
            copycat.email(seed, {
              domain: 'acme.org',
            }),
        },
        Comment: (x) => x(3),
      });
    },
  },
});
```

---

We specify that the author of each comment will be provided from an external source rather than being generated using the `connect` callback function.

```ts snaplet.config.ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
     async run(snaplet) {
      await snaplet.Post({
        title: 'Hello World!',
        User: {
          email: ({ seed }) =>
            copycat.email(seed, {
              domain: 'acme.org',
            }),
        },
        Comment: (x) => x(3, () => ({
          // focus(1:3)
          User: () => {

          }
        })),
      });
    },
  },
});
```

---

We can use the injected `store` to provide the `User` model we want to connect to. In this case the only generated `User` in the plan will be the author of the post.

```ts snaplet.config.ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
     async run(snaplet) {
      await snaplet.Post({
        title: 'Hello World!',
        User: {
          email: ({ seed }) =>
            copycat.email(seed, {
              domain: 'acme.org',
            }),
        },
        Comment: (x) => x(3, () => ({
          // focus(1:3)
          User: ({ store }) => {
            return store.User[0];
          }
        })),
      });
    },
  },
});
```

</CH.Scrollycoding>

##### `graph`

If your plan is complex, it can be quite challenging to find the right model to connect to. That's why we also provide the `graph` variable to the `connect` function.

The `graph` contains all the data that was generated as part of the plan, arranged to follow the shape of your plan.

And here is how you can use it:

```ts snaplet.config.ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
     async run(snaplet) {
      await snaplet.Post({
        title: 'Hello World!',
        User: {
          email: ({ seed }) => copycat.email(seed, { domain: 'acme.org' }),
        },
        Comment: (x) => x(3, () => ({
          // focus(1:4)
          // we alias the graph to posts to make it more readable
          User: ({ graph: posts }) => {
            return posts[0].User;
          }
        })),
      });
    },
  },
});
```

Here is what the `graph` looks like for this plan:

```ts
// as we started with snaplet.Post, the graph is an array of Post
const graph = [
  {
    User: User,
    Comment: [
      Comment,
      Comment,
      Comment
    ],
  },
];
```

##### `branch`

Now let's complexify our plan a bit:

- We want to generate 3 posts.
- The author of each post should also be the author of the post's comments.

It seems challenging to find the right User to connect to using `store` or `graph`. That's why we also provide the `branch` variable to the `connect` function.

The `branch` is a particular iteration of the `graph` that was generated. It matches the path to the `connect` function in which it is injected.

Let's take a look at the `branch` for our previous plan, adapted to our new requirements:

```ts snaplet.config.ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { copycat } from '@snaplet/copycat';

export default defineConfig({
  generate: {
     async run(snaplet) {
      await snaplet.Post({
        title: 'Hello World!',
        User: {
          email: ({ seed }) => copycat.email(seed, { domain: 'acme.org' }),
        },
        Comment: (x) => x(3, () => ({
          // focus(1:4)
          // we alias the branch to post to make it more readable
          User: ({ branch: post }) => {
            return post.User;
          }
        })),
      });
    },
  },
});
```

Generating 3 posts will result in 3 branches, each containing a post, its author and its comments.

In our above example, the `connect` function will receive the branch corresponding to its iteration. So the first `connect` function will receive the first branch, the second `connect` function will receive the second branch, and so on.

Here is what the `branch` looks like for this particular `connect` function:

```ts
// as we started with snaplet.Post, the branch is a Post model
const branch = {
  User: User,
  Comment: Comment,
};
```

#### Using `autoConnect` option

We provide a special option that you can activate in the options of a plan, called `autoConnect`.

When `true`, the plan will automatically connect models relationships to fulfill to the store if possible. The corresponding model will be picked randomly (but deterministically, we're using `copycat.oneOf` method under the hood).

In the following example, the `Post` model will be connected to one of the 3 `User` in the store.

```ts snaplet.config.ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';

export default defineConfig({
  generate: {
    async run(snaplet) {
      await snaplet.$pipe(
        snaplet.User((x) => x(3)),
        // mark
        snaplet.Post({}, { autoConnect: true })
      );
    },
  },
});
```

#### Augmenting external data with `$createStore`

Sometimes, you want to augment external data with generated data. For example, you might want to generate 10 `Post` for a particular `User` in your database.

For this purpose, we provide the `$createStore` utility function. It allows you to create a store and pass it as a plan's option:

```ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';
import { PrismaClient } from "@prisma/client"

const prisma = new PrismaClient();

export default defineConfig({
  generate: {
    async run(snaplet) {
      const user = await prisma.User.findUnique({ where: { email: 'alice@acme.com' } });

      const store = snaplet.$createStore({
        User: [user]
      });

      // The 10 Posts will be connected to the unique User in the store
      await snaplet.Post((x) => x(10), { autoConnect: true, store });
    },
  },
});
```

When using `$createStore`, the data are marked as external, and won't be persisted in the database. Only the generated data will be persisted.

You can mark use the `external` option if you want the data to be persisted:

```ts
// the initial data is not marked as external and will be persisted
const store = snaplet.$createStore({
  User: [user]
}, { external: false });

// we add another User to the store, this time marked as external.
// You can omit the external option, it defaults to true.
store.add('User', anotherUser, { external: true });
```

### Manipulating stores

We saw that a **plan** is persisting the generated data in a **store**, and the store will be turned into **SQL statements**.

Sometimes, it's easier to break down your plan into multiple plans, and then merge them together. That's why we provide the `$pipe` and `$merge` functions.

#### Using `$pipe`

The `$pipe` operator allows you to chain multiple plans together, injecting the `store` of the previous plan into the next plan.

```ts snaplet.config.ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';

export default defineConfig({
  generate: {
    async run(snaplet) {
      await snaplet.$pipe(
        snaplet.User((x) => x(3)),
        snaplet.Post({
          User: ({ store }) => {
            // this is the first User generated by the previous plan
            return store.User[0];
          }
        })
      );
    },
  },
});
```

#### Using `$merge`

The `$merge` operator allows you to merge multiple plans together, without injecting the `store` of the previous plan into the next plan.
All stores stay independent and are merged together once all the plans are generated.

```ts snaplet.config.ts
/// <reference path=".snaplet/snaplet.d.ts" />
import { defineConfig } from 'snaplet';

export default defineConfig({
  generate: {
    async run(snaplet) {
      await snaplet.$merge(
        snaplet.User((x) => x(3)),
        snaplet.Post({}),
        snaplet.Comment((x) => x(2))
      );
    },
  },
});
```